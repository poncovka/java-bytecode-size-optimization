%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Formát instrukčního souboru}

% TODO
% 4lensk0 prom2nn0

Při kompilaci \texttt{java} souboru překladač pro každou definovanou třídu a rozhraní vytvoří jeden \texttt{class} soubor. Tento soubor obsahuje binární reprezentaci kompilovaného mezikódu, který lze interpretovat prostřednictvím JVM.  V této kapitole popisuji formát \texttt{class} souboru dle specifikace ve verzi Java SE 8 Edition(X).

Pro popis formátu jsem zvolila rozšířenou Backus-Naurovu formu (?), která umožňuje zapsat syntaxi formálního jazyka pomocí pravidel a terminálních a nonterminálních symbolů. Nonterminální symboly jsou definovány pomocí definujícího symbolu \texttt{:=}, symbolu pro konkatenaci \texttt{,}, symbolu pro alternaci \texttt{$\mathtt{|}$}, symbolů pro nula a více opakování \texttt{\{\}}, ukončujícího symbolu \texttt{;} a pomocí graficky odlišených \T{terminálních} a \N{nonterminálních} symbolů. Symboly popisují jednotlivé struktury, ze kterých se \texttt{class} soubor skládá.

\section{Základní struktura}

Položky \texttt{class} souboru tvoří posloupnost osmibitových bajtů. Základní stavební jednotkou je tedy bajt, který je v pravidlech reprezentovaný symbolem \N{B}. Symbol $\langle n \rangle$\N{B}, kde $\langle n \rangle \in \{2,3,\dots\}$, reprezentuje $n$ bajtů. Terminály jsou hexadecimální reprezentací posloupnosti bajtů s prefixem \texttt{0x}. Vícebajtové datové hodnoty jsou uloženy v pořadí big-endian.

Základní struktura souboru je popsaná symbolem \N{classfile}. Soubor obsahuje informace o svém typu a verzi (\N{version}), disponuje tabulkou všech konstant, které se v souboru vyskytují (\N{constants}), nese informace o třídě (\N{class}), kterou reprezentuje, případně rozhraní, obsahuje seznam rozhraní (\N{interface\_list}), které reprezentovaná třída implementuje, případně rozhraní rozšiřuje, seznam členských proměnných třídy (\N{field\_list}), seznam metod (\N{method\_list}) a seznam atributů (\N{attribute\_list}). 

\begin{figure}[h!]
  \begin{tabular}{r c l}
  \N{classfile} &:=& \N{version}, \N{constants}, \N{class}, \N{interface\_list}, \N{field\_list}, \N{method\_list}, \N{attribute\_list};
  \end{tabular}
\end{figure}

Typ souboru je definován prvními čtyřmi bajty, které jsou popsané symbolem \N{magic\_number}. Verze souboru je tvořena hodnotou $M$ symbolu \N{major\_version} a hodnotou $m$ symbolu \N{minor\_version} jako $M.m$.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{version} &:=& \N{magic\_number}, \N{minor\_version}, \N{major\_version};\\
  \N{magic\_number} &:=& \T{0xCAFEBABE};\\
  \N{minor\_version} &:=& \N{2B};\\
  \N{major\_version} &:=& \N{2B};\\
  \end{tabular}
\end{figure}

\section{Konstanty}

Tabulka konstant obsahuje některé číselné konstanty, všechny řetězce a symbolické informace o všech třídách, rozhraních, metodách a členských proměnných, které se v souboru, instrukcích i atributech vyskytují. Tato tabulka se nazývá \textit{constant pool} a slouží v podstatě jako databáze dat, do které se pomocí indexů odkazují další položky souboru. Odkazem do tabulky konstant je tedy dále myšlen platný index do tabulky konstant adresující položku očekávaného typu.

Struktura tabulky konstant je popsána pravidlem pro \N{constants}. Symbol \N{constant\_pool\_count} reprezentuje hodnotu $1 + n$, kde $n$ je počet položek v tabulce konstant. Položky tabulky jsou indexované od jedné. Nultý index je vyhrazen pro odkaz na žádnou z položek. Samotná tabulka je reprezentovaná symbolem \N{constant\_pool}.

\begin{figure} [h!]

  \begin{tabular}{r c l}
  \N{constants} &:=& \N{constant\_pool\_count}, \N{constant\_pool}; \\
  \N{constant\_pool\_count} &:=& \N{2B}; \\
  \N{constant\_pool} &:=& \{
          \N{constant\_integer} \\
  &&  $|$ \N{constant\_float} \\
  &&  $|$ \N{constant\_long} \\
  &&  $|$ \N{constant\_double} \\ 
  &&  $|$ \N{constant\_utf8} \\
  &&  $|$ \N{constant\_string} \\ 
  &&  $|$ \N{constant\_nameAndType} \\ 
  &&  $|$ \N{constant\_class} \\
  &&  $|$ \N{constant\_fieldref} \\
  &&  $|$ \N{constant\_methodref} \\
  &&  $|$ \N{constant\_interfaceMethodref} \\
  &&  $|$ \N{constant\_methodHandle} \\ 
  &&  $|$ \N{constant\_methodType} \\
  &&  $|$ \N{constant\_invokeDynamic} \\ 
  &&  \}; \\
  \end{tabular}
\end{figure}

Každá položka tabulky je tvořena označením typu a posloupností bajtů s informacemi o položce. Položky mohou mít různou velikost v závislosti na svém typu a obsahu. Stejným způsobem jsou definovány všechny tabulky v \texttt{class} souboru. Jestliže se jedná o pole, pak prvky pole jsou stejného typu, a proto označení typu v prvcích chybí.

 Číselné konstanty jsou reprezentované symboly \N{constant\_integer}, \N{constant\_float}, \N{constant\_long} a \N{constant\_double} a skládají se jen z typu a číselné hodnoty. 
Symbol \N{constant\_utf8} reprezentuje řetězec v upraveném kódování \texttt{UTF-8} a skládá se z typu, délky pole bajtů a pole bajtů nesoucích reprezentaci řetězce. Znaky řetězce mohou být vhledem ke kódování tvořeny různými počty bajtů. 
Symbol \N{constant\_string} je reprezentací řetězcové konstanty a kromě typu obsahuje index do tabulky konstant na položku \N{constant\_utf8}. 
Třídy a rozhraní jsou reprezentované položkami \N{constant\_class} s odkazy na jejich název (\N{constant\_utf8}). 
Entity jako členské proměnné (i statické), metody třídy a metody rozhraní jsou reprezentované položkami \N{constant\_fieldref}, \N{constant\_methodref} a \N{constant\_interfaceMethodref} obsahujícími odkaz na třídu, případně rozhraní, dané entity (\N{constant\_class}), a odkaz na položku se jménem a typem této entity (\N{constant\_nameAndType}). 
Jméno a typ v položce \N{constant\_nameAndType} jsou odkazy na řetězce (\N{constant\_utf8}). 
Položky \N{constant\_methodHandle}, \N{constant\_methodType} a \N{constant\_invokeDynamic} souvisí s podporou dynamických jazyků.


% TODO interní formát jmen !!!!!!
Názvy tříd a rozhraní jsou interně uváděné v úplném tvaru, ale z historických důvodů se tečky nahrazují lomítky. Například, třída \texttt{Object} má úplný název \texttt{java.lang.Object} a interní název \texttt{java/lang/Object}. Typ proměnné nebo metody je specifikován řetězcem. Základní datové typy jsou reprezentované písmeny \texttt{B} pro \texttt{byte}, \texttt{C} pro \texttt{char}, \texttt{D} pro \texttt{double}, \texttt{F} pro \texttt{float}, \texttt{I} pro \texttt{int}, \texttt{J} pro \texttt{long}, \texttt{S} pro \texttt{short}, \texttt{Z} pro \texttt{boolean}. Typ reference na objekt je reprezentovaný řetězcem \texttt{L}$ClassName$\texttt{;}, kde $ClassName$ je interní název třídy nebo rozhraní. Typ reference na jednorozměrné pole je reprezentovaný řetězcem \texttt{[}$ComponentType$, kde $ComponentType$ je řetězec reprezentující základní datový typ, referenci na objekt nebo referenci na pole. Pomocí zanoření referencí na pole lze definovat referenci na vícerozměrné pole. Například, řetězec \texttt{Ljava/lang/Object;} označuje referenci na objekt typu \texttt{Object} a \texttt{[[[I} označuje referenci na trojrozměrné pole typu \texttt{int}. Typ metody je reprezentován řetězcem, který se skládá z výčtu typů formálních parametrů metody a typu její návratové hodnoty. Tedy například, typ metody s hlavičkou \texttt{int method(boolean b, Object o)} bude specifikovaný řetětězcem \texttt{(BLjava/lang/Object;)I}. Nemá-li metoda žádné parametry či nevrací žádnou hodnotu, pak je odpovídající chybějící typ nahrazen písmenem \texttt{V}.


\section{Třída}

% TODO access flags

Každý \texttt{class} soubor reprezentuje jednu třídu nebo rozhraní. Informace o reprezentované entitě jsou definované symbolem \N{class}. Položka \N{this\_class} je odkazem na tuto entitu v tabulce konstant, \N{super\_class} je odkaz na nadřazenou třídu a \N{access\_flags} je bitové pole příznaků pro přístup k této entitě.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{class} &:=& \N{access\_flags}, \N{this\_class}, \N{super\_class};\\
  \N{access\_flags} &:=& \N{2B}; \\
  \N{this\_class} &:=& \N{class\_ref};\\
  \N{super\_class} &:=& \N{class\_ref};\\
  \N{class\_ref} &:=& \N{constant\_pool\_index}; \\
  \N{constant\_pool\_index} &:=& \N{2B}; \\
  \end{tabular}
\end{figure}

Seznam rozhraní, které reprezentovaná třída implementuje, případně reprezentované rozhraní rozšiřuje, je definované v poli \N{interfaces} o \N{interface\_count} prvcích. Prvky jsou odkazy do tabulky konstant na položky \N{constant\_class} reprezentující nějaké rozhraní.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{interface\_list} &:=& \N{interface\_count}, \N{interfaces};\\
  \N{interfaces} &:=& \{ \N{class\_ref} \};\\
  \N{interface\_count} &:=& \N{2B};\\
  \end{tabular}
\end{figure}

\section{Členské proměnné}

% Popis struktury field\_info. Jakým způsobem jsou uložené členské proměnné?
% Popis descriptoru?

Členské proměnné třídy jsou definované v poli členských proměnných \N{fields} o \N{fields\_count} prvcích. Každá proměnná má pole příznaků dané symbolem \N{access\_flags}, jméno dané symbolem \N{name\_ref}, typ daný symbolem \N{descriptor\_ref} a seznam atributů daný symbolem \N{attribute\_list}. Jméno a typ jsou reprezentované odkazem do tabulky konstant na položku \N{utf8\_ref}. Atributům se věnuje kapitola (?).

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{field\_list} &:=& \N{fields\_count}, \N{fields};\\
  \N{fields} &:=& \{ \N{field\_info} \};\\
  \N{field\_info} &:=& \N{access\_flags}, \N{name\_ref}, \N{descriptor\_ref}, \N{attribute\_list};\\
  \N{fields\_count} &:=& \N{2B};\\
  \N{name\_ref} &:=& \N{utf8\_ref};\\
  \N{descriptor\_ref} &:=& \N{utf8\_ref};\\
  \N{utf8\_ref} &:=& \N{constant\_pool\_index}; \\
  \end{tabular}
\end{figure}

\section{Metody}

% Popis struktury method\_info. Jakým způsobem jsou uložené metody? Kde jsou uloženy instrukce?
% TODO jen abstraktní metoda nemá code?

Metody reprezentované třídy či rozhraní jsou definované v poli metod \N{methods} o \N{methods\_count} prvcích. Stejně jako u členských proměnných jsou metody popsané bitovým polem příznaků, jménem, typem a seznamem atributů.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{method\_list} &:=& \N{methods\_count}, \N{methods};\\
  \N{methods} &:=& \{ \N{method\_info} \};\\
  \N{method\_info} &:=& \N{access\_flags}, \N{name\_ref}, \N{descriptor\_ref}, \N{attribute\_list};\\
  \N{methods\_count} &:=& \N{2B};\\
  \end{tabular}
\end{figure}

Pokud metoda není abstraktní, pak jedním z jejích atributů je \texttt{Code} s kódem metody.
Tento atribut je definován symbolem \N{code\_attribute}. Položka \N{name\_ref} je odkazem do tabulky konstant na řetězec "Code". Položka \N{attribute\_length} určuje délku atributu v bajtech bez prvních šesti bajtů. Dále položky \N{max\_stack} a \N{max\_locals} označují maximální hloubku operačního zásobníku přepočtenou na jednotku hloubky (?) a maximální počet lokálních proměnných včetně parametrů. Kód metody je reprezentovaným polem bajtů \N{code} o délce \N{code\_length}. Symbol \N{attribute\_list} je seznamem atributů.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{code\_attribute} &:=& \N{name\_ref}, \N{attribute\_length}, \N{code\_info} \\
  \N{code\_info} &:=& \N{max\_stack}, \N{max\_locals}, \N{code\_list}, \N{exception\_list}, \N{attribute\_list}; \\ 
  \N{code\_list} &:=& \N{code\_length}, \N{code} ; \\ 
  \N{code} &:=& \{ \N{B} \}; \\ 
  \N{max\_stack} &:=& \N{2B}; \\ 
  \N{max\_locals} &:=& \N{4B}; \\ 
  \N{code\_length} &:=& \N{4B} ; \\ 
  \end{tabular}
\end{figure}

Informace o zpracování výjimek jsou dostupné v tabulce výjimek \N{exception\_table} o délce \N{exception\_table\_length}. Každá položka tabulky obsahuje dva indexy \N{start\_pc} a \N{end\_pc} do pole \N{code}, které společně definují blok instrukcí, pro které je odchycení dané výjimky aktivní. Dále index \N{handler\_pc} do pole \N{code} odkazující na začátek bloku pro zpracování výjimky. A nakonec index \N{catch\_type} do tabulky konstant na položku \N{constant\_class} reprezentující typ odchycené výjimky. Jestliže je tento index nulový, pak jsou odchytávány všechny výjimky. Na pořadí položek v tabulce výjimek se nevztahují žádná omezení, neboť při odchytávání výjimky se postupuje od nejniternějšího bloku.

% TODO doplnit ukázku kódu a bytekódu

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{exception\_list} &:=& \N{exception\_table\_length}, \N{exception\_table} ; \\ 
  \N{exception\_table} &:=& \{ \N{\N{start\_pc}, \N{end\_pc}, \N{handler\_pc}, \N{catch\_type}} \}; \\ 
  \N{start\_pc} &:=& \N{code\_index}; \\ 
  \N{end\_pc} &:=& \N{code\_index}; \\ 
  \N{handler\_pc} &:=& \N{code\_index}; \\ 
  \N{catch\_pc} &:=& \N{class\_ref}; \\ 
  \N{exception\_table\_length} &:=& \N{2B}; \\ 
  \N{code\_index} &:=& \N{2B}; \\
  \end{tabular}
\end{figure}

\section{Instrukce}

% Přehled instrukcí a krátké příklady bajkódu.

Každá instrukce se skládá z jednobajtového operačního kódu \textit{opcode} a nula a více operandů. Instrukce může dále pracovat s obsahem operačního zásobníku a má přístup do pole lokálních proměnných a tabulky konstant. Pro snazší orientaci je každému operačnímu kódu přiřazen jednoznačný název \textit{mnemonic}. V následujícím textu jsou instukce uvedené ve tvaru: $mnemonic$ $operand_1$ $operand_2$ \dots $operand_n$. Pokud nebude řečeno jinak, pak každý operand má velikost jednoho bajtu.

% zm9nit 6e operandy jsou ulo6en0 v big-endian order, batkód je zarovanný na 1 byte s výjimou switch, počet a velikost operandů určuje operační kód instrukce, zmínit kódování typu pomocí písmenke i,ld, ...

\subsubsection{Konstantní hodnoty}

Konstantní hodnotu lze dle jejího typu, velikosti a hodnoty vložit na zásobník několika způsoby.
Instrukce \texttt{aconst\_null} vloží na zásobník referenci na \texttt{null}. 
Instrukce \texttt{iconst\_}$value$, kde $value \in \{ \texttt{m1}, \texttt{0}, \texttt{1}, \texttt{2}, \dots, \texttt{5}\}$ a \texttt{m1} označuje hodnotu $-1$, vloží na zásobník hodnotu $value$ typu \texttt{int}. Obdobně lze instrukcí \texttt{fconst\_}$value$, kde $value \in \{\texttt{0}, \texttt{1}, \texttt{2}\}$, a instrukcemi \texttt{lconst\_}$value$ a \texttt{dconst\_}$value$, kde $value \in \{\texttt{0}, \texttt{1}\}$, vložit konstatní hodnoty typu \texttt{float}, \texttt{long} a \texttt{double}. 
Větší celočíselnou hodnotu typu \texttt{int} umožňují vložit instrukce \texttt{bipush} $value$ a \texttt{sipush} $value$, kde $value$ je jednobajtová, respektive dvoubajtová, znaménková hodnota.

Ve všech ostatních případech, je nutné vložit hodnotu z tabulky konstant. Pomocí instrukce \texttt{ldc} $index$, kde $index$ je jednobajtový index do tabulky konstant, lze vložit hodnotu typu \texttt{int} či \texttt{float} nebo referenci na objekt. Instrukce \texttt{ldc\_w} $index$ umožňuje použít dvoubajtový index. Instrukce \texttt{ldc2\_w} $index$ vloží na zásobník hodnotu typu \texttt{long} nebo \texttt{double} danou dvoubajtovým indexem  $index$.

\subsubsection{Práce s lokálními proměnnými}

Do lokální proměnné lze přiřadit hodnotu instrukcí $t$\texttt{store} $index$, kde $t \in \{  \}$ a $index$ je index do pole lokálních proměnných. Dané proměnné se přiřadí hodnota, která se odebere z vrcholu zásobníku. Na druhou stranu, instrukce $t$\texttt{load} $index$, načte hodnotu z dané lokální proměnné na zásobník. Pro lokální proměnné s indexy $index \in \{0,1,2,3\}$ lze použít jednobajtové instrukce $t$\texttt{store\_}$index$ a $t$\texttt{load\_}$index$.
Celočíselné lokální proměnné lze inkrementovat instrukcí \texttt{iinc} $index$ $value$, která k hodnotě proměnné na indexu $index$ přičte jednobajtovou znaménkovou hodnotu $value$.

\subsubsection{Práce s polem}

Pole lze vytvořit instrukcí \texttt{newarray} $type$, kde $type$ označuje typ pole. Instrukce načte ze zásobníku hodnotu $count$ typu \texttt{int}, vytvoří pole typu $type$ o délce $count$ a referenci na toto pole vloží na zásobník. Pole objektů umožňuje vytvořit instrukce \texttt{anewarray} $index$, kde $index$ je dvoubajtový index do tabulky konstant na typ vytvářeného pole. Typem zde může být třída, rozhraní nebo pole. Obdobně lze vytvořit vícerozměrné pole objektů instrukcí \texttt{multianewarray} $index$ $dimension$, kde $index$ je opět index do tabulky konstant a $dimension$ udává počet dimenzí vytvářeného pole. Ze zásobníku jsou načteny délky pro jednotlivé dimenze a je vložena reference na vícerozměrné pole objektů daného typu.

Instrukce $t$\texttt{astore}, kde $t \in \{\texttt{b}, \texttt{c}, \texttt{s}, \texttt{i}, \texttt{l}, \texttt{f},  \texttt{d}, \texttt{a}  \}$ určuje typ pole, umožňuje vložit hodnotu do pole. Ze zásobníku odebere hodnotu $value$, index $index$ a referenci na pole $array$ typu $t$ a provede operaci $array$[$index$] $:=$ $value$.
Instrukcí $t$\texttt{aload} lze hodnotu z pole načíst na zásobník. Ze zásobníku se odebere $index$ a $array$ a vloží se na něj hodnota $array$[$index$]. 

Délku pole lze zjistit instrukcí \texttt{arraylength}, která ze zásobníku odebere referenci na pole a vloží na něj délku tohoto pole.

\subsubsection{Metody a objekty}

Nový objekt lze vytvořit instrukcí \texttt{new} $index$, kde $index$ je dvoubajtový index do tabulky konstant na třídu nebo rozhraní. Instance třídy nebo rozhraní se inicializuje a její reference se vloží na zásobník.

Přístup ke členským proměnným objektu umožňují instrukce \texttt{getfield} $index$ a \texttt{putfield} $index$, kde $index$ je dvoubajtový index do tabulky konstant na členskou proměnnou. Instrukce \texttt{getfield} odebere ze zásobníku referenci na objekt, získá hodnotu dané členské proměnné a vloží ji na zásobník. Instrukce \texttt{putfield} odebere ze zásobníku hodnotu $value$ a referenci na objekt a dané členské proměnné tohoto objektu přiřadí hodnotu $value$. Obdobně lze přistupovat k proměnným třídy pomocí instrukcí \texttt{getstatic} $index$ a \texttt{putstatic} $index$. Instrukce však ze zásobníku nenačítají referenci na objekt a třídu proměnné určí z položky v tabulce konstant pro členskou proměnnou.

% invokevirtual/special/static/interface/dynamic




Instrukce \texttt{instanceof} $index$ umožňuje ověřit, zda je objekt daný referencí z vrcholu zásobníku instancí třídy dané dvoubajtovým indexem do tabulky konstant  $index$, případně zda objekt implementuje rozhraní dané tímto indexem. Výsledek ověření je vložen na zásobník v podobě hodnoty typu \texttt{int} ($1$ úspěch, $0$ neúspěch). Obdobně se chová instrukce \texttt{checkcast} $index$, ale v případě úspěchu vloží referenci na objekt zpět na zásobník, v případě neúspěchu vyhodí výjimku \texttt{ClassCastException}.


Výjimku lze vyhodit instrukcí \texttt{athrow}. Ze zásobníku se odebere reference na instanci třídy \texttt{Throwable} nebo její podtřídu a v tabulce výjimek se vyhledá blok pro zpracování této instance. Pokud pro danou výjimku takový blok neexistuje, vykonávání aktuální metody $method$ se okamžitě bez předání návratové hodnoty ukončí a výjimka se znovu vyvolá v metodě, která metodu $method$ zavolala. 

% Zkontrolovat:

Vstupu do synchronizovaného bloku instrukcí předchází vstup do monitoru daného objektu. Opuštění takového bloku znamená uvolnění tohoto monitoru. Toto chování zajišťují instrukce \texttt{monitorenter} a \texttt{monitorexit}. Referenci na objekt, s jehož monitorem budou pracovat, získávají z operačního zásobníku.

\subsubsection{Porovnávání a podmíněné skoky}

Instrukce \texttt{if}$condition$ $next$, kde $condition \in \{ \texttt{eq}, \texttt{ne}, \texttt{lt}, \texttt{le}, \texttt{ge}, \texttt{gt}\}$ a $next$ je dvoubajtová znaménková hodnota, umožňuje provést podmíněný skok na jinou instrukci. Ze zásobníku odebere hodnotu typu \texttt{int} a porovná ji s nulou na rovnost, nerovnost, menší než, menší nebo rovno, větší než či větší nebo rovno dle $condition$. Pokud je podmínka pro skok splněna, pokračuje se instrukcí ve vzdálenosti $next$ od pozice aktuální instrukce. Jinak se pokračuje následující instrukcí. Instrukce \texttt{if\_icmp}$condition$ umožňuje vzájemně porovnat dvě hodnoty typu \texttt{int}.
 Pro hodnoty typu \texttt{long}, \texttt{float} a \texttt{double} je nutné nejprve provést jednu z instrukcí \texttt{lcmp}, \texttt{fcmp}$x$ a \texttt{dcmp}$x$, kde $x \in \{\texttt{l}, \texttt{g} \}$. Instrukce ze zásobníku odebere dvě hodnoty, porovná je a výsledek porovnání vloží na zásobník ($1$ pro větší než, $0$ pro rovnost, $-1$ pro menší než). Podmíněný skok lze následně vykonat instrukcí \texttt{if}$condition$.
Pro porovnání objektu s \texttt{null} jsou k dispozici instrukce \texttt{ifnull} a \texttt{ifnonnull}. Pro porovnání dvou objektů lze použít instrukce \texttt{if\_acmpeq} a \texttt{if\_acmpne}.

Příkaz \texttt{switch} se převádí na jednu z instrukcí \texttt{tableswitch} a \texttt{lookupswitch}. První instrukce pracuje s tabulkou relativních adres, kde vstupní hodnota lze přímo převést na index do tabulky. Druhá instrukce pracuje s tabulkou dvojic klíč-adresa, kde pro vstupní hodnotu je třeba nalézt dvojici s odpovídajícím klíčem. Tabulka adres je vhodnější, nejsou-li jednotlivé případy příkazu \texttt{switch} navzájem příliš rozptýlené, jinak je lepší použít tabulku dvojic.

První instrukce je definovaná jako \texttt{tableswitch} $pad$ $default$ $low$ $high$ $table$, kde $pad$ je výplň o délce nula až tři bajty, která slouží ke správnému zarovnání dalších položek, $default$, $low$ a $high$ jsou čtyřbajtové hodnoty a $table$ je sekvence čtyřbajtových hodnot o délce $high$ - $low$ + 1. Instrukce načte ze zásobníku hodnotu $value$ typu \texttt{int} a ověří zda leží v rozsahu hodnot $low$ a $high$. Pokud ne, pak pro skok použije relativní adresu $default$, pokud ano, pak použije adresu z tabulky relativních adres $table$ na pozici $value$ - $low$. Následně se provede skok.

Podoba druhé instrukce je \texttt{lookupswitch} $pad$ $default$ $count$ $pairs$, kde $count$ je čtyřbajtová hodnota označující počet dvojic v tabulce $pairs$ a $pairs$ je sekvence dvojic čtyřbajtových hodnot $key$ a $next$. Dvojice jsou v tabulce seřazené podle hodnoty $key$. Instrukce načte ze zásobníku hodnotu $value$ typu \texttt{int}, vyhledá v tabulce $pairs$ dvojici, kde $key$ je rovno $value$, a odpovídající hodnotu $next$ použije jako relativní adresu skoku. Pokud takovou dvojici nenajde, skočí na relativní adresu $default$.

\subsubsection {Řízení toku}

\texttt{goto} $next$ dvoubajtová relativní adresa
\texttt{goto\_w} $next$ čtyřbajtová relativní adresa

$t$\texttt{return}, kde $t \in \{   \}$, odebere hodnotu $value$ ze zásobníku, obnoví rámec volající metody a vloží $value$ na operační zásobník této metody.
\texttt{return} 

\texttt{jsr} $next$, kde $index$ je dvoubajtová hodnota s relativní adresou skoku. Adresa následující instrukce je vložena na zásobník pro pozdější návrat ze subrutiny.
\texttt{jsr\_w} používá čtyřbajtový index
\texttt{ret} $index$, kde $index$ je indexem do tabulky lokálních proměnných na proměnnou typu \texttt{returnAddress}. Obsah této proměnné udává adresu pro skok.

\subsubsection{Konverze hodnot}

Hodnotu z vrcholu zásobníku lze konvertovat na jiný datový typ instrukcí typu $t_1$\texttt{2}$t_2$, kde $t_1, t_2 \in \{\texttt{i}, \texttt{l},\texttt{f},\texttt{d}\}$ a pro $t_1$ rovno $\texttt{i}$ platí $t_2 \in \{\texttt{b}, \texttt{c},\texttt{s}\}$. Hodnota je pak konvertovaná z typu $t_1$ na typ $t_2$.

\subsubsection{Práce se zásobníkem}

Níže zmíněné instrukce umožňují manipulovat se zásobníkem. Způsob manipulace je popsaný pomocí tzv. jednotek délky zásobníku, přičemž některé hodnoty na zásobníku se mohou skládat ze dvou jednotek. Po provedení instrukce musí být vždy zachována integrita těchto hodnot. %Porušení integrity by bylo odhaleno při verifikací \texttt{class} souboru.

K odstranění hodnot z vrcholu zásobníku slouží instrukce \texttt{pop} a \texttt{pop2}, které odstraní jednu, případně dvě jednotky. Instrukce \texttt{dup} duplikuje jednotku na vrcholu zásobníku, zatímco instrukce \texttt{dup\_x1} a \texttt{dup\_x2} duplikovanou jednotku navíc přesunou o dvě, případně tři jednotky níže. Obdobně instrukce \texttt{dup2} duplikuje dvojici jednotek na vrcholu zásobníku a instrukce \texttt{dup2\_x1} a \texttt{dup2\_x2} dvojici navíc přesunou o tři, případně čtyři, jednotky níže. Instrukce 
\texttt{swap} prohodí pořadí dvou jednotek na vrcholu zásobníku.

\subsubsection{Matematické a bitové operace}

Instrukce pro matematické operace jsou ve tvaru $t operation$, 
kde $t \in \{\texttt{i},\texttt{f}, \texttt{l}, \texttt{d} \}$ specifikuje typ operandů 
a $operation \in \{\texttt{add},\texttt{sub}, \texttt{mul}, \texttt{div}, \texttt{rem}, \texttt{neg} \}$ určuje jednu z matematických operací pro součet, rozdíl, násobení, dělení, zbytek po dělení a negaci. 
Instrukce pro bitové operace jsou ve tvaru $t operation$, 
kde $t \in \{\texttt{i}, \texttt{l}\}$ 
a $operation \in \{\texttt{shl},\texttt{shr}, \texttt{ushr}, \texttt{and}, \texttt{or}, \texttt{xor}\}$ označuje bitový posuv doleva, aritmetický posuv doprava, logický posuv doprava, logický součin, logický součet nebo  exkluzivní logický součet. 
Uvedené instrukce odeberou ze zásobníku příslušný počet operandů a vrátí na zásobník výsledek operace.

\subsubsection{Další instrukce}

Instrukce \texttt{nop} nic nedělá. Instrukce \texttt{breakpoint}, \texttt{impdep1} a \texttt{impdep1} jsou rezervované pro použití v jiných programech, ale ve validním \texttt{class} souboru se objevit nemohou.

% TODO příklad na inicializaci lokálních proměnných a matematické operace

% TODO příklad na pole, vytvoření, délka

% TODO příklad na práci s objekty

% TODO příklad na podmínky a skoky

% TODO příklad na lookup table a switch

% TODO příklad na volání metod a používání fieldů a statických věcí

% TODO příklad na výjímky

% TODO příklad na monitor enter a exit


\section{Atributy}

Reprezentovaná třída, případně rozhraní, metody, členské proměnné a i některé atributy mají definovaný seznam atributů. Seznam se skládá z tabulky atributů \N{attributes} o \N{attributes\_count} položkách. Typ atributu je daný odkazem \N{name\_ref} na název atributu, délka atributu bez prvních šesti bajtů je daná hodnotou \N{attribute\_length}. Další informace, které atribut nese v položce \N{info}, liší podle typu atributu.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{attribute\_list} &:=& \N{attributes\_count}, \N{attributes};\\
  \N{attributes} &:=& \{ \N{name\_ref}, \N{attribute\_length}, \N{info} \};\\
  \N{info} &:=& \{ \N{B} \};\\
  \N{attributes\_count} &:=& \N{2B}; \\
  \N{attribute\_length} &:=& \N{4B};\\
  \end{tabular}
\end{figure}

Specifikace (?) definuje 23 atributů. Překladače však mohou definovat a vkládat do \texttt{class} souborů i atributy vlastní. Pokud je JVM neumí rozpoznat, pak je ignoruje. Atributy mají různou míru důležitosti vzhledem k interpretaci \texttt{class} souboru. 

Pro správnou interpretaci JVM je důležitých následujících pět atributů. Jedním z atributů členské proměnné může být atribut \texttt{ConstantValue}, který v sobě nese index do tabulky konstant na položku s číselnou nebo řetězcovou konstantou. Jestliže je daná proměnná statická, pak je jí při inicializaci třídy přiřazena právě tato hodnota. Atribut \texttt{Code} reprezentující instrukce metody byl představen v kapitole (?). Jedním z atributů \texttt{Code} může být \texttt{StackMapTable}. Tento atribut je důležitý pro typovou kontrolu při verifikaci \texttt{class} souborů. Pro každý základní blok instrukcí jsou specifikovány typy lokálních proměnných a hodnot na operačním zásobníku. U starších verzí \texttt{class} souboru se provádí typová inference pomocí analýzy datového toku. \texttt{Exceptions} je atribut metody. Obsahuje odkazy do tabulky konstant na typy kontrolovaných výjimek, které metoda může vyhodit. Atribut \texttt{BootstrapMethods} souvisí s dynamickými jazyky.

Následujících dvanáct atributů je podstatných pro správnou interpretaci knihovnami Java platformy. Vnitřní třídy třídy reprezentované \texttt{class} souborem jsou vyjmenované v atributu \texttt{InnerClasses}. Pro každou vnitřní třídu atribut uchovává bitové pole příznaků, ukazatel na název vnitřní třídy, ukazatel na vnější třídu a ukazatel na vnitřní třídu. Každá lokální nebo anonymní třída pak musí mít atribut \texttt{EnclosingMethod} obsahující ukazatel na vnější třídu a ukazatel na metodu, která definici třídy uzavírá. Atribut \texttt{Synthetic} reprezentuje příznak, že daný člen třídy se nevyskytuje ve zdrojovém kódu a zároveň není standardním členem. Atribut \texttt{Signature} nese deklaraci třídy, rozhraní, členské proměnné nebo metody, v níž se vyskytují typové proměnné nebo parametrizované typy. Jména a přístupové příznaky formálních parametrů metody mohou být dostupné v atributu \texttt{MethodParameters}.

% TODO Runtime*Annotations, AnnotationDefault, 

Další atributy jsou pouze informativní a mohou sloužit například k ladění chyb ve zdrojovém souboru. Atribut \texttt{SourceFile} obsahuje odkaz na název zdrojového kódu. Atribut \texttt{SourceDebugExtension} v sobě nese řetězec s ladícími informace. \texttt{LineNumberTable} reprezentuje mapování indexů do pole instrukcí na čísla řádků zdrojového kódu. Informace o lokálních proměnných metody mohou být dostupné v atributu \texttt{LocalVariableTable}, kde je obsažen rozsah instrukcí, ve kterém proměnná nese hodnotu, odkaz na název proměnné, odkaz na typ proměnné a index do pole lokálních proměnných. Stejné informace nese atribut \texttt{LocalVariableTypeTable}, ale pouze pro proměnné, jejichž typy používají typované proměnné nebo parametrizované typy. Atribut \texttt{Deprecated} slouží k indikaci toho, že třída, metoda, členská proměnná či rozhraní jsou zastaralé.

%=========================================================================

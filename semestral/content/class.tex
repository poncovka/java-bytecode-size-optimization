%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Formát instrukčního souboru}

% TODO
% * dopsat info u položek
% * definovat byte
% * nastudovat instrukce
% * ověřit velikosti "sdílených" nonterminálů !!!

Při kompilaci \texttt{java} souboru překladač pro každou definovanou třídu a rozhraní vytvoří jeden soubor s příponou \texttt{.class} (dále \texttt{class} soubor). Tento soubor obsahuje binární reprezentaci kompilovaného mezikódu, který lze interpretovat prostřednictvím JVM. V této kapitole popisuji formát \texttt{class} souboru dle specifikace ve verzi Java SE 8 Edition(X).

Pro popis formátu jsem zvolila rozšířenou Backus-Naurovu formu (?), která umožňuje zapsat syntaxi formálního jazyka pomocí pravidel a terminálních a nonterminálních symbolů. Nonterminální symboly jsou definovány pomocí definujícího symbolu \texttt{:=}, symbolu pro konkatenaci \texttt{,}, symbolu pro alternaci \texttt{$\mathtt{|}$}, symbolů pro nula a více opakování \texttt{\{\}}, ukončujícího symbolu \texttt{;} a pomocí graficky odlišených \T{terminálních} a \N{nonterminálních} symbolů.

\section{Základní struktura}

% Jaká je základní struktura class souboru?

Položky \texttt{class} souboru tvoří posloupnost osmibitových bajtů. Základní stavební jednotkou je tedy bajt, který je v pravidlech reprezentovaný symbolem \N{B}. Symbol $\langle n \rangle$\N{B}, kde $\langle n \rangle \in \{2,3,\dots\}$, reprezentuje $n$ bajtů. Terminály jsou hexadecimální reprezentací posloupnosti bajtů s prefixem \texttt{0x}. 

Základní struktura souboru je popsaná pravidlem pro symbol \N{classfile}. Soubor obsahuje informace o jeho typu a verzi (\N{version}), disponuje tabulkou všech konstant, které se v souboru vyskytují (\N{constants}), nese informace o třídě, kterou reprezentuje, případně rozhraní (\N{class}), obsahuje seznam rozhraní, které reprezentovaná třída implementuje, případně rozhraní rozšiřuje  (\N{interface\_list}), seznam členských proměnných třídy (\N{field\_list}), seznam metod (\N{method\_list}) a seznam atributů (\N{attribute\_list}). 

\begin{figure}[h!]
  \begin{tabular}{r c l}
  \N{classfile} &:=& \N{version}, \N{constants}, \N{class}, \N{interface\_list}, \N{field\_list}, \N{method\_list}, \N{attribute\_list};
  \end{tabular}
\end{figure}

Typ souboru je definován prvními čtyřmi bajty, které jsou popsané symbolem \N{magic\_number}. Verze souboru je tvořena hodnotou $M$ symbolu \N{major\_version} a hodnotou $m$ symbolu \N{minor\_version} jako $M.m$.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{version} &:=& \N{magic\_number}, \N{minor\_version}, \N{major\_version};\\
  \N{magic\_number} &:=& \T{0xCAFEBABE};\\
  \N{minor\_version} &:=& \N{2B};\\
  \N{major\_version} &:=& \N{2B};\\
  \end{tabular}
\end{figure}

\section{Konstanty}

% Popis struktury constant\_pool. Jakým způsobem jsou ukládané konstanty? Jak jsou reprezentované různé typy?
% Jednotlivé typy konstant lze nejspíš popsat jen slovně.
% TODO
% * zmínit run-time constant pool, kdy se symbolické reference nahrazují konkrétními referencemi

Tabulka konstant obsahuje některé číselné konstanty, všechny řetězce a symbolické informace o všech třídách, rozhraních, metodách a členských proměnných, které se v souboru, instrukcích i atributech vyskytují. Tato tabulka se nazývá \textit{constant pool} a slouží v podstatě jako databáze dat, do které se pomocí indexů odkazují další položky souboru. 

Struktura tabulky konstant je popsána pravidlem pro \N{constants}. Symbol \N{constant\_pool\_count} reprezentuje hodnotu $1 + n$, kde $n$ je počet položek v tabulce konstant. Položky tabulky jsou indexované od jedné. Nultý index je vyhrazen pro odkaz na žádnou z položek. Samotná tabulka je reprezentovaná symbolem \N{constant\_pool}.

\begin{figure} [h!]

  \begin{tabular}{r c l}
  \N{constants} &:=& \N{constant\_pool\_count}, \N{constant\_pool}; \\
  \N{constant\_pool\_count} &:=& \N{2B}; \\
  \N{constant\_pool} &:=& \{
          \N{constant\_integer} \\
  &&  $|$ \N{constant\_float} \\
  &&  $|$ \N{constant\_long} \\
  &&  $|$ \N{constant\_double} \\ 
  &&  $|$ \N{constant\_utf8} \\
  &&  $|$ \N{constant\_string} \\ 
  &&  $|$ \N{constant\_nameAndType} \\ 
  &&  $|$ \N{constant\_class} \\
  &&  $|$ \N{constant\_fieldref} \\
  &&  $|$ \N{constant\_methodref} \\
  &&  $|$ \N{constant\_interfaceMethodref} \\
  &&  $|$ \N{constant\_methodHandle} \\ 
  &&  $|$ \N{constant\_methodType} \\
  &&  $|$ \N{constant\_invokeDynamic} \\ 
  &&  \}; \\
  \end{tabular}
\end{figure}

Každá položka tabulky je tvořena označením typu a posloupností bajtů s informacemi o položce. Položky mohou mít různou velikost v závislosti na svém typu a obsahu. Stejným způsobem jsou definovány všechny tabulky v \texttt{class} souboru. Jestliže se jedná o pole, pak prvky pole jsou stejného typu, a proto označení typu v prvcích chybí.

 Číselné konstanty jsou reprezentované symboly \N{constant\_integer}, \N{constant\_float}, \N{constant\_long} a \N{constant\_double} a skládají se jen z typu a číselné hodnoty. 
Symbol \N{constant\_utf8} reprezentuje řetězec v upraveném kódování \texttt{UTF-8} a skládá se z typu, délky pole bajtů a pole bajtů nesoucích reprezentaci řetězce. Znaky řetězce mohou být vhledem ke kódování tvořeny různými počty bajtů. 
Symbol \N{constant\_string} je reprezentací řetězcové konstanty a kromě typu obsahuje index do tabulky konstant na položku \N{constant\_utf8}. 
Třídy a rozhraní jsou reprezentované položkami \N{constant\_class} s odkazy na jejich název (\N{constant\_utf8}). 
Entity jako členské proměnné, metody třídy a metody rozhraní jsou reprezentované položkami \N{constant\_fieldref}, \N{constant\_methodref} a \N{constant\_interfaceMethodref} obsahujícími odkaz na třídu, případně rozhraní, dané entity (\N{constant\_class}), a odkaz na položku se jménem a typem této entity (\N{constant\_nameAndType}). 
Jméno a typ v položce \N{constant\_nameAndType} jsou odkazy na řetězce (\N{constant\_utf8}). 
Položky \N{constant\_methodHandle}, \N{constant\_methodType} a \N{constant\_invokeDynamic} souvisí s podporou dynamických jazyků.

\section{Třída}

% TODO access flags

Každý \texttt{class} soubor reprezentuje jednu třídu nebo rozhraní. Informace o reprezentované entitě jsou definované symbolem \N{class}. Položka \N{this\_class} je odkazem na tuto entitu v tabulce konstant, \N{super\_class} je odkaz na nadřazenou třídu a \N{access\_flags} je bitové pole příznaků pro přístup k této entitě.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{class} &:=& \N{access\_flags}, \N{this\_class}, \N{super\_class};\\
  \N{access\_flags} &:=& \N{2B}; \\
  \N{this\_class} &:=& \N{class\_ref};\\
  \N{super\_class} &:=& \N{class\_ref};\\
  \N{class\_ref} &:=& \N{constant\_pool\_index}; \\
  \N{constant\_pool\_index} &:=& \N{2B}; \\
  \end{tabular}
\end{figure}

Seznam rozhraní, které reprezentovaná třída implementuje, případně reprezentované rozhraní rozšiřuje, je definované v poli \N{interfaces} o \N{interface\_count} prvcích. Prvky jsou odkazy do tabulky konstant na položky \N{constant\_class} reprezentující nějaké rozhraní.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{interface\_list} &:=& \N{interface\_count}, \N{interfaces};\\
  \N{interfaces} &:=& \{ \N{class\_ref} \};\\
  \N{interface\_count} &:=& \N{2B};\\
  \end{tabular}
\end{figure}

\section{Členské proměnné}

% Popis struktury field\_info. Jakým způsobem jsou uložené členské proměnné?
% Popis descriptoru?

Členské proměnné třídy jsou definované v poli členských proměnných \N{fields} o \N{fields\_count} prvcích. Každá proměnná má pole příznaků dané symbolem \N{access\_flags}, jméno dané symbolem \N{name\_ref}, typ daný symbolem \N{descriptor\_ref} a seznam atributů daný symbolem \N{attribute\_list}. Jméno a typ jsou reprezentované odkazem do tabulky konstant na položku \N{utf8\_ref}. Atributům se věnuje kapitola (?).

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{field\_list} &:=& \N{fields\_count}, \N{fields};\\
  \N{fields} &:=& \{ \N{field\_info} \};\\
  \N{field\_info} &:=& \N{access\_flags}, \N{name\_ref}, \N{descriptor\_ref}, \N{attribute\_list};\\
  \N{fields\_count} &:=& \N{2B};\\
  \N{name\_ref} &:=& \N{utf8\_ref};\\
  \N{descriptor\_ref} &:=& \N{utf8\_ref};\\
  \N{utf8\_ref} &:=& \N{constant\_pool\_index}; \\
  \end{tabular}
\end{figure}

\section{Metody}

% Popis struktury method\_info. Jakým způsobem jsou uložené metody? Kde jsou uloženy instrukce?
% TODO jen abstraktní metoda nemá code?

Metody reprezentované třídy či rozhraní jsou definované v poli metod \N{methods} o \N{methods\_count} prvcích. Stejně jako u členských proměnných jsou metody popsané bitovým polem příznaků, jménem, typem a seznamem atributů.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{method\_list} &:=& \N{methods\_count}, \N{methods};\\
  \N{methods} &:=& \{ \N{method\_info} \};\\
  \N{method\_info} &:=& \N{access\_flags}, \N{name\_ref}, \N{descriptor\_ref}, \N{attribute\_list};\\
  \N{methods\_count} &:=& \N{2B};\\
  \end{tabular}
\end{figure}

Pokud metoda není abstraktní, pak jedním z jejích atributů je \texttt{Code} s kódem metody.
Tento atribut je definován symbolem \N{code\_attribute}. Položka \N{name\_ref} je odkazem do tabulky konstant na řetězec "Code". Položka \N{attribute\_length} určuje délku atributu v bajtech bez prvních šesti bajtů. Dále položky \N{max\_stack} a \N{max\_locals} označují maximální hloubku operačního zásobníku přepočtenou na jednotku hloubky (?) a maximální počet lokálních proměnných včetně parametrů. Kód metody je reprezentovaným polem bajtů \N{code} o délce \N{code\_length}. Symbol \N{attribute\_list} je seznamem atributů.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{code\_attribute} &:=& \N{name\_ref}, \N{attribute\_length}, \N{code\_info} \\
  \N{code\_info} &:=& \N{max\_stack}, \N{max\_locals}, \N{code\_list}, \N{exception\_list}, \N{attribute\_list}; \\ 
  \N{code\_list} &:=& \N{code\_length}, \N{code} ; \\ 
  \N{code} &:=& \{ \N{B} \}; \\ 
  \N{max\_stack} &:=& \N{2B}; \\ 
  \N{max\_locals} &:=& \N{4B}; \\ 
  \N{code\_length} &:=& \N{4B} ; \\ 
  \end{tabular}
\end{figure}

Informace o zpracování výjimek jsou dostupné v tabulce výjimek \N{exception\_table} o délce \N{exception\_table\_length}. Každá položka tabulky obsahuje dva indexy \N{start\_pc} a \N{end\_pc} do pole \N{code}, které společně definují blok instrukcí, pro které je odchycení dané výjimky aktivní. Dále index \N{handler\_pc} do pole \N{code} odkazující na začátek bloku pro zpracování výjimky. A nakonec index \N{catch\_type} do tabulky konstant na položku \N{constant\_class} reprezentující typ odchycené výjimky. Jestliže je tento index nulový, pak jsou odchytávány všechny výjimky. Na pořadí položek v tabulce výjimek se nevztahují žádná omezení, neboť při odchytávání výjimky se postupuje od nejniternějšího bloku.

% TODO doplnit ukázku kódu a bytekódu

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{exception\_list} &:=& \N{exception\_table\_length}, \N{exception\_table} ; \\ 
  \N{exception\_table} &:=& \{ \N{\N{start\_pc}, \N{end\_pc}, \N{handler\_pc}, \N{catch\_type}} \}; \\ 
  \N{start\_pc} &:=& \N{code\_index}; \\ 
  \N{end\_pc} &:=& \N{code\_index}; \\ 
  \N{handler\_pc} &:=& \N{code\_index}; \\ 
  \N{catch\_pc} &:=& \N{class\_ref}; \\ 
  \N{exception\_table\_length} &:=& \N{2B}; \\ 
  \N{code\_index} &:=& \N{2B}; \\
  \end{tabular}
\end{figure}

\section{Instrukce}

% Přehled instrukcí a krátké příklady bajkódu.

\section{Atributy}

% Základní přehled atributů, jen ty podstatné, neboť jich je mnoho.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{attribute\_list} &:=& \N{attributes\_count}, \N{attributes};\\
  \N{attributes} &:=& \{ \N{name\_ref}, \N{attribute\_length}, \N{info} \};\\
  \N{info} &:=& \{ \N{B} \};\\
  \N{attributes\_count} &:=& \N{2B}; \\
  \N{attribute\_length} &:=& \N{4B};\\
  \end{tabular}
\end{figure}


%=========================================================================

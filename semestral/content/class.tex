%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Formát instrukčního souboru}

% TODO
% * dopsat info u položek
% * definovat byte
% * nastudovat instrukce
% * ověřit velikosti "sdílených" nonterminálů !!!

Při kompilaci \texttt{java} souboru překladač pro každou definovanou třídu a rozhraní vytvoří jeden soubor s příponou \texttt{.class} (dále \texttt{class} soubor). Tento soubor obsahuje binární reprezentaci kompilovaného mezikódu, který lze interpretovat prostřednictvím JVM. V této kapitole popisuji formát \texttt{class} souboru dle specifikace ve verzi Java SE 8 Edition(X).

Pro popis formátu jsem zvolila rozšířenou Backus-Naurovu formu (?), která umožňuje zapsat syntaxi formálního jazyka pomocí pravidel a terminálních a nonterminálních symbolů. Nonterminální symboly jsou definovány pomocí definujícího symbolu \texttt{:=}, symbolu pro konkatenaci \texttt{,}, symbolu pro alternaci \texttt{$\mathtt{|}$}, symbolů pro nula a více opakování \texttt{\{\}}, ukončujícího symbolu \texttt{;} a pomocí graficky odlišených \T{terminálních} a \N{nonterminálních} symbolů.

\section{Základní struktura}

% Jaká je základní struktura class souboru?

Položky \texttt{class} souboru tvoří posloupnost osmibitových bajtů. Základní stavební jednotkou je tedy bajt, který je v pravidlech reprezentovaný symbolem \N{B}. Symbol $\langle n \rangle$\N{B}, kde $\langle n \rangle \in \{2,3,\dots\}$, reprezentuje $n$ bajtů. Terminály jsou hexadecimální reprezentací posloupnosti bajtů s prefixem \texttt{0x}. 

Základní struktura souboru je popsaná pravidlem pro symbol \N{classfile}. Soubor obsahuje informace o jeho typu a verzi (\N{version}), disponuje tabulkou všech konstant, které se v souboru vyskytují (\N{constants}), nese informace o třídě, kterou reprezentuje, případně rozhraní (\N{class}), obsahuje seznam rozhraní, které reprezentovaná třída implementuje, případně rozhraní rozšiřuje  (\N{interface\_list}), seznam členských proměnných třídy (\N{field\_list}), seznam metod (\N{method\_list}) a seznam atributů (\N{attribute\_list}). 

\begin{figure}[h!]
  \begin{tabular}{r c l}
  \N{classfile} &:=& \N{version}, \N{constants}, \N{class}, \N{interface\_list}, \N{field\_list}, \N{method\_list}, \N{attribute\_list};
  \end{tabular}
\end{figure}

Typ souboru je definován prvními čtyřmi bajty, které jsou popsané symbolem \N{magic\_number}. Verze souboru je tvořena hodnotou $M$ symbolu \N{major\_version} a hodnotou $m$ symbolu \N{minor\_version} jako $M.m$.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{version} &:=& \N{magic\_number}, \N{minor\_version}, \N{major\_version};\\
  \N{magic\_number} &:=& \T{0xCAFEBABE};\\
  \N{minor\_version} &:=& \N{2B};\\
  \N{major\_version} &:=& \N{2B};\\
  \end{tabular}
\end{figure}

\section{Konstanty}

% Popis struktury constant\_pool. Jakým způsobem jsou ukládané konstanty? Jak jsou reprezentované různé typy?
% Jednotlivé typy konstant lze nejspíš popsat jen slovně.
% TODO
% * zmínit run-time constant pool, kdy se symbolické reference nahrazují konkrétními referencemi

Tabulka konstant obsahuje některé číselné konstanty, všechny řetězce a symbolické informace o všech třídách, rozhraních, metodách a členských proměnných, které se v souboru, instrukcích i atributech vyskytují. Tato tabulka se nazývá \textit{constant pool} a slouží v podstatě jako databáze dat, do které se pomocí indexů odkazují další položky souboru. 

Struktura tabulky konstant je popsána pravidlem pro \N{constants}. Symbol \N{constant\_pool\_count} reprezentuje hodnotu $1 + n$, kde $n$ je počet položek v tabulce konstant. Položky tabulky jsou indexované od jedné. Nultý index je vyhrazen pro odkaz na žádnou z položek. Samotná tabulka je reprezentovaná symbolem \N{constant\_pool}.

\begin{figure} [h!]

  \begin{tabular}{r c l}
  \N{constants} &:=& \N{constant\_pool\_count}, \N{constant\_pool}; \\
  \N{constant\_pool\_count} &:=& \N{2B}; \\
  \N{constant\_pool} &:=& \{
          \N{constant\_integer} \\
  &&  $|$ \N{constant\_float} \\
  &&  $|$ \N{constant\_long} \\
  &&  $|$ \N{constant\_double} \\ 
  &&  $|$ \N{constant\_utf8} \\
  &&  $|$ \N{constant\_string} \\ 
  &&  $|$ \N{constant\_nameAndType} \\ 
  &&  $|$ \N{constant\_class} \\
  &&  $|$ \N{constant\_fieldref} \\
  &&  $|$ \N{constant\_methodref} \\
  &&  $|$ \N{constant\_interfaceMethodref} \\
  &&  $|$ \N{constant\_methodHandle} \\ 
  &&  $|$ \N{constant\_methodType} \\
  &&  $|$ \N{constant\_invokeDynamic} \\ 
  &&  \}; \\
  \end{tabular}
\end{figure}

Každá položka tabulky je tvořena označením typu a posloupností bajtů s informacemi o položce. Položky mohou mít různou velikost v závislosti na svém typu a obsahu. Stejným způsobem jsou definovány všechny tabulky v \texttt{class} souboru. Jestliže se jedná o pole, pak prvky pole jsou stejného typu, a proto označení typu v prvcích chybí.

 Číselné konstanty jsou reprezentované symboly \N{constant\_integer}, \N{constant\_float}, \N{constant\_long} a \N{constant\_double} a skládají se jen z typu a číselné hodnoty. 
Symbol \N{constant\_utf8} reprezentuje řetězec v upraveném kódování \texttt{UTF-8} a skládá se z typu, délky pole bajtů a pole bajtů nesoucích reprezentaci řetězce. Znaky řetězce mohou být vhledem ke kódování tvořeny různými počty bajtů. 
Symbol \N{constant\_string} je reprezentací řetězcové konstanty a kromě typu obsahuje index do tabulky konstant na položku \N{constant\_utf8}. 
Třídy a rozhraní jsou reprezentované položkami \N{constant\_class} s odkazy na jejich název (\N{constant\_utf8}). 
Entity jako členské proměnné, metody třídy a metody rozhraní jsou reprezentované položkami \N{constant\_fieldref}, \N{constant\_methodref} a \N{constant\_interfaceMethodref} obsahujícími odkaz na třídu, případně rozhraní, dané entity (\N{constant\_class}), a odkaz na položku se jménem a typem této entity (\N{constant\_nameAndType}). 
Jméno a typ v položce \N{constant\_nameAndType} jsou odkazy na řetězce (\N{constant\_utf8}). 
Položky \N{constant\_methodHandle}, \N{constant\_methodType} a \N{constant\_invokeDynamic} souvisí s podporou dynamických jazyků.

\section{Třída}

% TODO access flags

Každý \texttt{class} soubor reprezentuje jednu třídu nebo rozhraní. Informace o reprezentované entitě jsou definované symbolem \N{class}. Položka \N{this\_class} je odkazem na tuto entitu v tabulce konstant, \N{super\_class} je odkaz na nadřazenou třídu a \N{access\_flags} je bitové pole příznaků pro přístup k této entitě.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{class} &:=& \N{access\_flags}, \N{this\_class}, \N{super\_class};\\
  \N{access\_flags} &:=& \N{2B}; \\
  \N{this\_class} &:=& \N{class\_ref};\\
  \N{super\_class} &:=& \N{class\_ref};\\
  \N{class\_ref} &:=& \N{constant\_pool\_index}; \\
  \N{constant\_pool\_index} &:=& \N{2B}; \\
  \end{tabular}
\end{figure}

Seznam rozhraní, které reprezentovaná třída implementuje, případně reprezentované rozhraní rozšiřuje, je definované v poli \N{interfaces} o \N{interface\_count} prvcích. Prvky jsou odkazy do tabulky konstant na položky \N{constant\_class} reprezentující nějaké rozhraní.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{interface\_list} &:=& \N{interface\_count}, \N{interfaces};\\
  \N{interfaces} &:=& \{ \N{class\_ref} \};\\
  \N{interface\_count} &:=& \N{2B};\\
  \end{tabular}
\end{figure}

\section{Členské proměnné}

% Popis struktury field\_info. Jakým způsobem jsou uložené členské proměnné?
% Popis descriptoru?

Členské proměnné třídy jsou definované v poli členských proměnných \N{fields} o \N{fields\_count} prvcích. Každá proměnná má pole příznaků dané symbolem \N{access\_flags}, jméno dané symbolem \N{name\_ref}, typ daný symbolem \N{descriptor\_ref} a seznam atributů daný symbolem \N{attribute\_list}. Jméno a typ jsou reprezentované odkazem do tabulky konstant na položku \N{utf8\_ref}. Atributům se věnuje kapitola (?).

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{field\_list} &:=& \N{fields\_count}, \N{fields};\\
  \N{fields} &:=& \{ \N{field\_info} \};\\
  \N{field\_info} &:=& \N{access\_flags}, \N{name\_ref}, \N{descriptor\_ref}, \N{attribute\_list};\\
  \N{fields\_count} &:=& \N{2B};\\
  \N{name\_ref} &:=& \N{utf8\_ref};\\
  \N{descriptor\_ref} &:=& \N{utf8\_ref};\\
  \N{utf8\_ref} &:=& \N{constant\_pool\_index}; \\
  \end{tabular}
\end{figure}

\section{Metody}

% Popis struktury method\_info. Jakým způsobem jsou uložené metody? Kde jsou uloženy instrukce?
% TODO jen abstraktní metoda nemá code?

Metody reprezentované třídy či rozhraní jsou definované v poli metod \N{methods} o \N{methods\_count} prvcích. Stejně jako u členských proměnných jsou metody popsané bitovým polem příznaků, jménem, typem a seznamem atributů.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{method\_list} &:=& \N{methods\_count}, \N{methods};\\
  \N{methods} &:=& \{ \N{method\_info} \};\\
  \N{method\_info} &:=& \N{access\_flags}, \N{name\_ref}, \N{descriptor\_ref}, \N{attribute\_list};\\
  \N{methods\_count} &:=& \N{2B};\\
  \end{tabular}
\end{figure}

Pokud metoda není abstraktní, pak jedním z jejích atributů je \texttt{Code} s kódem metody.
Tento atribut je definován symbolem \N{code\_attribute}. Položka \N{name\_ref} je odkazem do tabulky konstant na řetězec "Code". Položka \N{attribute\_length} určuje délku atributu v bajtech bez prvních šesti bajtů. Dále položky \N{max\_stack} a \N{max\_locals} označují maximální hloubku operačního zásobníku přepočtenou na jednotku hloubky (?) a maximální počet lokálních proměnných včetně parametrů. Kód metody je reprezentovaným polem bajtů \N{code} o délce \N{code\_length}. Symbol \N{attribute\_list} je seznamem atributů.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{code\_attribute} &:=& \N{name\_ref}, \N{attribute\_length}, \N{code\_info} \\
  \N{code\_info} &:=& \N{max\_stack}, \N{max\_locals}, \N{code\_list}, \N{exception\_list}, \N{attribute\_list}; \\ 
  \N{code\_list} &:=& \N{code\_length}, \N{code} ; \\ 
  \N{code} &:=& \{ \N{B} \}; \\ 
  \N{max\_stack} &:=& \N{2B}; \\ 
  \N{max\_locals} &:=& \N{4B}; \\ 
  \N{code\_length} &:=& \N{4B} ; \\ 
  \end{tabular}
\end{figure}

Informace o zpracování výjimek jsou dostupné v tabulce výjimek \N{exception\_table} o délce \N{exception\_table\_length}. Každá položka tabulky obsahuje dva indexy \N{start\_pc} a \N{end\_pc} do pole \N{code}, které společně definují blok instrukcí, pro které je odchycení dané výjimky aktivní. Dále index \N{handler\_pc} do pole \N{code} odkazující na začátek bloku pro zpracování výjimky. A nakonec index \N{catch\_type} do tabulky konstant na položku \N{constant\_class} reprezentující typ odchycené výjimky. Jestliže je tento index nulový, pak jsou odchytávány všechny výjimky. Na pořadí položek v tabulce výjimek se nevztahují žádná omezení, neboť při odchytávání výjimky se postupuje od nejniternějšího bloku.

% TODO doplnit ukázku kódu a bytekódu

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{exception\_list} &:=& \N{exception\_table\_length}, \N{exception\_table} ; \\ 
  \N{exception\_table} &:=& \{ \N{\N{start\_pc}, \N{end\_pc}, \N{handler\_pc}, \N{catch\_type}} \}; \\ 
  \N{start\_pc} &:=& \N{code\_index}; \\ 
  \N{end\_pc} &:=& \N{code\_index}; \\ 
  \N{handler\_pc} &:=& \N{code\_index}; \\ 
  \N{catch\_pc} &:=& \N{class\_ref}; \\ 
  \N{exception\_table\_length} &:=& \N{2B}; \\ 
  \N{code\_index} &:=& \N{2B}; \\
  \end{tabular}
\end{figure}

\section{Instrukce}

% Přehled instrukcí a krátké příklady bajkódu.

Každá instrukce se skládá z jednobajtového operačního kódu \textit{opcode} a nula a více operandů. Instrukce může dále pracovat s obsahem operačního zásobníku a má přístup do pole lokálních proměnných a tabulky konstant. Pro snazší orientaci je každému operačnímu kódu přiřazen jednoznačný název \textit{mnemonic}. V následujícím textu jsou instukce uvedené ve tvaru: $mnemonic$ $operand_1$ $operand_2$ \dots $operand_n$. Pokud nebude řečeno jinak, pak každý operand má velikost jednoho bajtu.

\subsubsection{Konstantní hodnoty}

Konstantní hodnotu lze dle jejího typu, velikosti a hodnoty vložit na zásobník několika způsoby.
Instrukce \texttt{aconst\_null} vloží na zásobník referenci na \texttt{null}. 
Instrukce \texttt{iconst\_}$value$, kde $value \in \{ \texttt{m1}, \texttt{0}, \texttt{1}, \texttt{2}, \dots, \texttt{5}\}$ a \texttt{m1} označuje hodnotu $-1$, vloží na zásobník hodnotu $value$ typu \texttt{int}. Obdobně lze instrukcí \texttt{fconst\_}$value$, kde $value \in \{\texttt{0}, \texttt{1}, \texttt{2}\}$, a instrukcemi \texttt{lconst\_}$value$ a \texttt{dconst\_}$value$, kde $value \in \{\texttt{0}, \texttt{1}\}$, vložit konstatní hodnoty typu \texttt{float}, \texttt{long} a \texttt{double}. 
Větší celočíselnou hodnotu typu \texttt{int} umožňují vložit instrukce \texttt{bipush} $value$ a \texttt{sipush} $value$, kde $value$ je jednobajtová, respektive dvoubajtová, znaménková hodnota.

Ve všech ostatních případech, je nutné vložit hodnotu z tabulky konstant. Pomocí instrukce \texttt{ldc} $index$, kde $index$ je jednobajtový index do tabulky konstant, lze vložit hodnotu typu \texttt{int} či \texttt{float} nebo referenci na objekt. Instrukce \texttt{ldc\_w} $index$ umožňuje použít dvoubajtový index. Instrukce \texttt{ldc2\_w} $index$ vloží na zásobník hodnotu typu \texttt{long} nebo \texttt{double} danou dvoubajtovým indexem  $index$.

\subsubsection{Práce s lokálními proměnnými}

Do lokální proměnné lze přiřadit hodnotu instrukcí $t$\texttt{store} $index$, kde $t \in \{  \}$ a $index$ je index do pole lokálních proměnných. Dané proměnné se přiřadí hodnota, která se odebere z vrcholu zásobníku. Na druhou stranu, instrukce $t$\texttt{load} $index$, načte hodnotu z dané lokální proměnné na zásobník. Pro lokální proměnné s indexy $index \in \{0,1,2,3\}$ lze použít jednobajtové instrukce $t$\texttt{store\_}$index$ a $t$\texttt{load\_}$index$.
Celočíselné lokální proměnné lze inkrementovat instrukcí \texttt{iinc} $index$ $value$, která k hodnotě proměnné na indexu $index$ přičte jednobajtovou znaménkovou hodnotu $value$.

\subsubsection{Práce s polem}

Pole lze vytvořit instrukcí \texttt{anewarray} $index$, kde  $index$ je dvoubajtový index do tabulky konstant na typ vytvářeného pole. Typem pole může být třída, rozhraní nebo pole. Ze zásobníku se odebere hodnota $count$ určující délku pole a vloží reference na vytvořené pole. Prvky pole jsou inicializované  na \texttt{null}. Délku pole lze zjistit instrukcí \texttt{arraylength}, která ze zásobníku odebere referenci na pole a vloží na něj délku tohoto pole.

Instrukce $t$\texttt{astore}, kde $t \in \{\texttt{b}, \texttt{c}, \texttt{s}, \texttt{i}, \texttt{l}, \texttt{f},  \texttt{d}, \texttt{a}  \}$ určuje typ pole, umožňuje vložit hodnotu do pole. Ze zásobníku odebere hodnotu $value$, index $index$ a referenci na pole $array$ typu $t$ a provede operaci $array$[$index$] $:=$ $value$.
Instrukcí $t$\texttt{aload} lze hodnotu z pole načíst na zásobník. Ze zásobníku se odebere $index$ a $array$ a vloží se na něj hodnota $array$[$index$]. 

\subsubsection{Metody a objekty}

% checkcast, nthrow, monitor



\subsubsection{Porovnávání a podmíněné skoky}

Instrukce \texttt{if}$condition$ $next$, kde $condition \in \{ \texttt{eq}, \texttt{ne}, \texttt{lt}, \texttt{le}, \texttt{ge}, \texttt{gt}\}$ a $next$ je dvoubajtová znaménková hodnota, umožňuje provést podmíněný skok na jinou instrukci. Ze zásobníku odebere hodnotu typu \texttt{int} a porovná ji s nulou na rovnost, nerovnost, menší než, menší nebo rovno, větší než či větší nebo rovno dle $condition$. Pokud je podmínka pro skok splněna, pokračuje se instrukcí ve vzdálenosti $next$ od pozice aktuální instrukce. Jinak se pokračuje následující instrukcí. Instrukce \texttt{if\_icmp}$condition$ umožňuje vzájemně porovnat dvě hodnoty typu \texttt{int}. Dva objekty lze na rovnost a nerovnost porovnat instrukcemi \texttt{if\_acmpeq} a \texttt{if\_acmpne}. Pro hodnoty typu \texttt{long}, \texttt{float} a \texttt{double} je nutné nejprve provést jednu z instrukcí \texttt{lcmp}, \texttt{fcmp}$x$ a \texttt{dcmp}$x$, kde $x \in \{\texttt{l}, \texttt{g} \}$. Instrukce ze zásobníku odebere dvě hodnoty, porovná je a výsledek porovnání vloží na zásobník ($1$ pro větší než, $0$ pro rovnost, $-1$ pro menší než). Podmíněný skok lze následně vykonat instrukcí \texttt{if}$condition$.

% switch

\subsubsection {Řízení toku}

% return, goto

\subsubsection{Konverze hodnot}

Hodnotu z vrcholu zásobníku lze konvertovat na jiný datový typ instrukcí typu $t_1$\texttt{2}$t_2$, kde $t_1, t_2 \in \{\texttt{i}, \texttt{l},\texttt{f},\texttt{d}\}$ a pro $t_1$ rovno $\texttt{i}$ platí $t_2 \in \{\texttt{b}, \texttt{c},\texttt{s}\}$. Hodnota je pak konvertovaná z typu $t_1$ na typ $t_2$.

\subsubsection{Práce se zásobníkem}


\subsubsection{Další instrukce}

% nop, breakpoint, impdep1, impdep2

\subsubsection{Matematické a bitové operace}

Instrukce pro matematické operace jsou ve tvaru $t operation$, 
kde $t \in \{\texttt{i},\texttt{f}, \texttt{l}, \texttt{d} \}$ specifikuje typ operandů 
a $operation \in \{\texttt{add},\texttt{sub}, \texttt{mul}, \texttt{div}, \texttt{rem}, \texttt{neg} \}$ určuje jednu z matematických operací pro součet, rozdíl, násobení, dělení, zbytek po dělení a negaci. 
Instrukce pro bitové operace jsou ve tvaru $t operation$, 
kde $t \in \{\texttt{i}, \texttt{l}\}$ 
a $operation \in \{\texttt{shl},\texttt{shr}, \texttt{ushr}, \texttt{and}, \texttt{or}, \texttt{xor}\}$ označuje bitový posuv doleva, aritmetický posuv doprava, logický posuv doprava, logický součin, logický součet nebo  exkluzivní logický součet. 
Uvedené instrukce odeberou ze zásobníku příslušný počet operandů a vrátí na zásobník výsledek operace.


% TODO příklad na inicializaci lokálních proměnných a matematické operace

% TODO příklad na pole, vytvoření, délka

% TODO příklad na práci s objekty

% TODO příklad na podmínky a skoky

% TODO příklad na lookup table a switch

% TODO příklad na volání metod a používání fieldů a statických věcí

% TODO příklad na výjímky

% TODO příklad na monitor enter a exit


\section{Atributy}

% Základní přehled atributů, jen ty podstatné, neboť jich je mnoho.

Reprezentovaná třída, případně rozhraní, metody, členské proměnné a i některé atributy mají definovaný seznam atributů. Seznam se skládá z tabulky atributů \N{attributes} o \N{attributes\_count} položkách. Typ atributu je daný odkazem \N{name\_ref} na název atributu, délka atributu bez prvních šesti bajtů je daná hodnotou \N{attribute\_length}. Další informace, které atribut nese v položce \N{info}, liší podle typu atributu.

\begin{figure} [h!]
  \begin{tabular}{r c l}
  \N{attribute\_list} &:=& \N{attributes\_count}, \N{attributes};\\
  \N{attributes} &:=& \{ \N{name\_ref}, \N{attribute\_length}, \N{info} \};\\
  \N{info} &:=& \{ \N{B} \};\\
  \N{attributes\_count} &:=& \N{2B}; \\
  \N{attribute\_length} &:=& \N{4B};\\
  \end{tabular}
\end{figure}

% TODO dopsat atributy, vykašlat se na strukturu a jen napsat, k čemu slouží

Specifikace (?) definuje 23 atributů. Překladače však mohou definovat a vkládat do \texttt{class} souborů i atributy vlastní. Pokud je JVM neumí rozpoznat, pak je ignoruje. Atributy mají různou míru důležitosti vzhledem k interpretaci \texttt{class} souboru. 

Pro správnou interpretaci JVM je důležitých následujících pět atributů. Jedním z atributů členské proměnné může být atribut \texttt{ConstantValue}, který v sobě nese index do tabulky konstant na položku s číselnou nebo řetězcovou konstantou. Jestliže je daná proměnná statická, pak je jí při inicializaci třídy přiřazena právě tato hodnota. Atribut \texttt{Code} reprezentující instrukce metody byl představen v kapitole (?). Jedním z atributů \texttt{Code} může být \texttt{StackMapTable}. Tento atribut je důležitý pro typovou kontrolu při verifikaci \texttt{class} souborů. Pro každý základní blok instrukcí jsou specifikovány typy lokálních proměnných a hodnot na operačním zásobníku. U starších verzí \texttt{class} souboru se provádí typová inference pomocí analýzy datového toku. \texttt{Exceptions} je atribut metody. Obsahuje odkazy do tabulky konstant na typy kontrolovaných výjimek, které metoda může vyhodit. Atribut \texttt{BootstrapMethods} souvisí s dynamickými jazyky.

Následujících dvanáct atributů je podstatných pro správnou interpretaci knihovnami Java platformy. Vnitřní třídy třídy reprezentované \texttt{class} souborem jsou vyjmenované v atributu \texttt{InnerClasses}. Pro každou vnitřní třídu atribut uchovává bitové pole příznaků, ukazatel na název vnitřní třídy, ukazatel na vnější třídu a ukazatel na vnitřní třídu. Každá lokální nebo anonymní třída pak musí mít atribut \texttt{EnclosingMethod} obsahující ukazatel na vnější třídu a ukazatel na metodu, která definici třídy uzavírá. Atribut \texttt{Synthetic} reprezentuje příznak, že daný člen třídy se nevyskytuje ve zdrojovém kódu a zároveň není standardním členem. Atribut \texttt{Signature} nese deklaraci třídy, rozhraní, členské proměnné nebo metody, v níž se vyskytují typové proměnné nebo parametrizované typy. Jména a přístupové příznaky formálních parametrů metody mohou být dostupné v atributu \texttt{MethodParameters}.

% TODO Runtime*Annotations, AnnotationDefault, 

Další atributy jsou pouze informativní a mohou sloužit například k ladění chyb ve zdrojovém souboru. Atribut \texttt{SourceFile} obsahuje odkaz na název zdrojového kódu. Atribut \texttt{SourceDebugExtension} v sobě nese řetězec s ladícími informace. \texttt{LineNumberTable} reprezentuje mapování indexů do pole instrukcí na čísla řádků zdrojového kódu. Informace o lokálních proměnných metody mohou být dostupné v atributu \texttt{LocalVariableTable}, kde je obsažen rozsah instrukcí, ve kterém proměnná nese hodnotu, odkaz na název proměnné, odkaz na typ proměnné a index do pole lokálních proměnných. Atribut \texttt{LocalVariableTypeTable} nese stejné informace, ale pouze pro proměnné, jejichž typy používají typované proměnné nebo parametrizované typy.

% LineNumberTable, LocalVariableTable, LocalVariableTypeTable, Deprecated,


%=========================================================================

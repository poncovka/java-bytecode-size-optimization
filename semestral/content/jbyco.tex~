%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Nástroj pro analýzu bajtkódu}\label{Tool}

V této kapitole popisuji analýzu, návrh a implementaci nástroje \texttt{jbyco}. Nástroj je určen pro zpracování velkého množství souborů a získání dat, která jsou vhodná pro analýzu bajtkódu.

\section{Analýza problému a návrh řešení}\label{ToolDesign}

Pro analýzu bajtkódu jsem potřebovala získat data, která by vhodným způsobem reprezentovala analyzovaný bajtkód. Zajímaly mne celkové součty položek v \texttt{class} souboru, využití lokálních proměnných a parametrů a typické sekvence instrukcí. Dále jsem potřebovala vyřešit načítání velkého množství vstupních dat.

U hledání typických sekvencí jsem zvažovala jednotlivé sekvence a jejich četnosti zaznamenávat jednoduše pomocí tabulky klíč-hodnota. Takový přístup mi nepřipadal vhodný z hlediska paměťové složitosti, neboť by to znamenalo udržovat v paměti všechny podsekvence sekvencí instrukcí. Rozhodla jsem se proto pro reprezentaci sekvencí pomocí orientovaného acyklického grafu, tzv. grafu sufixů. Na instrukce se lze dívat jako na prvky abecedy a na sekvence instrukcí jako na řetězce. Pak definované cesty v grafu sufixů tvoří sufixy reprezentovaných řetězců. Prefixy těchto sufixů pak tvoří všechny podřetězce reprezentovaných řetězců. Graf sufixů se skládá z kořene a uzlů. Všechny uzly kromě kořene reprezentují prvky abecedy a pro každou hranu je definovaná množina cest, které danou hranou prochází. Každá taková cesta v grafu má vlastní čítač, který určuje, kolik stejných daná cesta reprezentuje. Když se do grafu přidává další sufix, postupuje se grafem směrem od kořenu. Pokud je aktuální prvek sufixu stejný jako prvek některého ze sousedů aktuálního uzlu, pak se daný uzel stane aktuálním a začne se zpracovávat následující prvek sufixu. Pokud takový soused neexistuje, vybere se z aktuálního uzlu nedosažitelný uzel se stejným prvkem. K tomuto uzlu se vytvoří z aktuálního uzlu hrana, vytvoří se nová cesta a uzel se označí za aktuální. Jestliže takový uzel neexistuje, pak se vytvoří nový uzel, hrana i cesta a nový uzel se stane aktuálním. Po vložení posledního prvku sufixu se inkrementuje čítač cesty, kterou sufix duplikuje, nebo se vytvoří cesta nová, pokud už vytvořena nebyla. Cílem je v podstatě minimalizovat duplicitu podřetězců v grafu.

V takto vytvořeném grafu sufixů lze následně začít zjednodušovat jeho hrany, kde je součet čítačů všech cest na této hraně menší než daná hodnota. Prvek uzlu, do kterého vede taková hrana, lze nahradit tzv. divokou kartou a sekvenčně i paralelně sousedící uzly s divokou kartou lze sloučit do jednoho uzlu. V takto zjednodušeném grafu lze nalézt typické vzory sekvencí instrukcí.

\section{Popis implementace}\label{ToolImplementation}

Nástroj jsem implementovala v jazyce Java 8. Balíček \texttt{jbyco} obsahuje třídu \texttt{App} s metodou \texttt{main}. V této metodě se zpracují parametry, vytvoří se iterátor vstupních souborů a spustí daná analýza. Iterátor vstupních souborů je reprezentovaný třídou \texttt{BytecodeFiles} z balíčku \texttt{jbyco.io}. Balíček obsahuje všechny třídy pro vstupně-výstupní operace. Třída  \texttt{BytecodeFiles} rekurzivně prochází všechny soubory, složky a \texttt{jar} soubory a vrací instance třídy \texttt{BytecodeFile} reprezentující \texttt{class} soubory. Rozhraní \texttt{Analyzer} z balíčku \texttt{jbyco.analyze} popisuje rozhraní třídy, která slouží k analýze. S  \texttt{class} soubory při analýze manipuluji pomocí nástroje BCEL. V balíčku \texttt{jbyco.analyze.size} jsou třídy potřebné k analýze velikosti, v balíčku \texttt{jbyco.analyze.locals} třídy určené k analýze využití lokálních proměnných a parametrů a v balíčku
\texttt{jbyco.analyze.patterns} třídy pro nalezení typických sekvencí instrukcí. Výstupem každé analýzy je vytištěná tabulka se zjištěnými daty. Balíček \texttt{jbyco.analyze.patterns.graph} obsahuje třídy pro práci s grafem sufixů.

Překlad nástroje lze provést příkazem \texttt{gradle build}. Aplikaci lze spustit příkazem \texttt{gradle run --myargs=\{help\}}, který vypíše nápovědu k programu.

Analýza velikosti a analýza využití proměnných běží i pro velké množství souborů velmi rychle, zatímco vyhledávání typických vzorů je velmi pomalé. Při bližším zkoumání jsem odhalila, že nejvíce času program stráví zajišťováním acykličnosti grafu. To, že graf není strom, je zajímavé z hlediska úspory paměti i zjednodušování hran. Cenou je však čas běhu programu.




%=========================================================================

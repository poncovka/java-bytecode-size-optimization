%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Nástroj pro optimalizaci velikosti bajtkódu}\label{Jbyco}

% TODO 
% * zmínit, že záleží na pořadí, a že každá optimalizace produkuje další možnosti k optimalizaci, mebo taky ne

V~této kapitole popisuji návrh a implementaci nástroje \texttt{jbyco} nebo-li Java Bytecode Optimizer určeného k optimalizaci velikosti \texttt{class} souborů. Nástroj implementuje optimalizační metody, které jsem navrhla v~předchozí kapitole. Efektivita těchto metod je na základě výstupů programu vyhodnocena v~kapitole \ref{Jbyco:Results}.

\section{Požadavky na program}\label{Jbyco:Requirements}

Cílem programu je implementovat navržené optimalizační metody a na testovacím vzorku \texttt{class} souborů demonstrovat jejich efektivitu. Zaměřila jsem se na metody pro optimalizaci sekvencí instrukcí. Jedním z~požadavků je proto i návrh vhodného programového rozhraní, který umožní snadno implementovat nové optimalizační metody.

\section{Návrh programu}\label{Jbyco:Design}

Při návrhu programu bylo potřeba se zamyslet nad pořadím aplikací optimalizačních metod. Dále bylo třeba navrhnout rozhraní pro optimalizaci sekvencí instrukcí.

\subsection{Pořadí optimalizačních metod}

U~některých optimalizačních metod může záležet na pořadí, v~jakém se aplikují. Například metodu pro substituci číselných konstant má smysl uskutečnit až jako poslední krok optimalizace, neboť jiné metody by mohly tuto substituci zvrátit. Na druhou stranu metoda pro odstranění zbytečných atributů může usnadnit další manipulaci s~kódem a je proto vhodné ji aplikovat při načtení vstupního bajtkódu. 

U~optimalizací sekvencí instrukcí může docházet k~tomu, že některé optimalizace budou vytvářet příležitosti pro další optimalizace. Vzhledem k~uspořádání zásobníkového kódu pak může být výhodnější aplikovat metody pro sekvence instrukcí na kód v~opačném směru, tedy od poslední instrukce k~první. Nejprve se tak zkoumají operace a jejich parametry, předtím než se začnou zkoumat další vztahy mezi instrukcemi. Tento způsob práce s~bajtkódem lze podpořit expanzí duplikací. Pokud je možné instrukci pro duplikaci aplikovat na úrovni instrukcí kódu, může tato aplikace vytvořit nové příležitosti pro optimalizace.
Konečný návrh na pořadí optimalizačních metod je následující:

\begin{enumerate}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}
\item Odstranění zbytečných atributů.
\item Expanze duplikací. 
\item Zjednodušení kódu.
\item Redukce duplikací.
\item Substituce číselných konstant.
\end{enumerate}


\subsection{Návrh rozhraní pro peephole optimalizace}

Většina navržených optimalizačních metod v~kapitole \ref{Optimization:Methods} je založených na nalezení vzorové sekvence instrukcí a náhradě této sekvence za optimalizované řešení. Tento způsob optimalizace se nazývá peephole optimalizace \cite{} a je specifický tím, že se vždy zkoumá jen malý úsek kódu. Nezbytnou součástí návrhu programu \texttt{jbyco} je tedy i návrh rozhraní pro peephole optimalizace. Konkrétně je třeba navrhnout, jakým způsobem budou definovány vzorové sekvence, jak budou vzorové sekvence rozpoznávány v~kódu určeném k~optimalizaci a jak bude probíhat samotná úprava kódu.

Způsobů implementace peephole optimalizace je mnoho \cite{}. Jako přímé řešení se nabízí převádět vstupní bajtkód na řetězcovou reprezentaci. Vzorové sekvence by pak byly popsány regulárními výrazy a problematika nalezení a úpravy bajtkódu by se zjednodušila na prosté hledání a nahrazování regulárních výrazů v~řetězci. Na závěr by bylo nutné řetězcovou reprezentaci opět převést na sekvenci instrukcí. Výhodou tohoto přístupu je snadné ladění, neboť řetězcová reprezentace kódu je snadno čitelná.

Efektivnější variantou by mohlo být hledání regulárními výrazy přímo nad instrukcemi bajtkódu. Regulární výrazy pro popis vzorových sekvencí by bylo možné předzpracovat a vygenerovat konečný stavový automat, který bude tyto výrazy rozpoznávat. Nalezené sekvence instrukcí pak mohou být nahrazeny za optimální. Pokud bude automat generován v~době překladu, pak by takové řešení mělo být velice rychlé. Vyžaduje však implementovat nástroje pro lexikální a syntaktickou analýzu regulárních výrazů, nástroje pro převod regulárních výrazů na konečný automat a nástroje pro minimalizaci konečného automatu. Pokud se však sleví z~požadavků na sílu jazyka pro popis vzorových sekvencí, lze tuto variantu zjednodušit.

Většinu vzorových sekvencí v~navržených optimalizačních metodách tvoří posloupnost instrukcí konstantní délky. Vzorové instrukce jsou specifikovány svými operačními kódy a omezeními kladenými na jejich parametry. Jako možné řešení se proto nabízí definovat vzorové sekvence pomocí posloupností operačních kódů a teprve při nalezení odpovídající sekvence kontrolovat další omezení. Pokud jsou všechna omezení splněna, může být sekvence optimalizována. Ve své implementaci jsem zvolila tuto variantu. 

Každá peephole optimalizace je tedy definována posloupností symbolů, které reprezentují množiny operačních kódů, a akcí, které provádí dodatečné kontroly a optimalizaci. Jedním z~výstupů akce je informace o~tom, zda se optimalizace provedla či neprovedla.
Rozpoznávání posloupností symbolů lze realizovat jednoduchým konečným automatem, jehož stavy jsou indexy do posloupnosti symbolů. Počátečním stavem je nula a koncovým stavem je délka posloupnosti. Pokud operační kód instrukce na vstupu patří do množiny reprezentované symbolem na indexu určeném aktuálním stavem, automat provede přechod na následující index. Pokud automat přejde do koncového stavu, provede se pro nalezenou sekvenci instrukcí odpovídající akce.

\section{Popis implementace}

Program jsem implementovala v~jazyce Java 8 za použití knihovny ASM 5.0 a knihovny \texttt{jbyco-common}, která vznikla v~rámci implementace nástroje \texttt{jbyca}. Překlad a instalaci zajišťuje knihovna Gradle 2.7. V~balíčku \texttt{jbyco.optimization} je umístěná třída \texttt{Application} s~hlavní metodou \texttt{main}. Tato metoda zpracuje parametry, inicializuje instanci třídy \texttt{Optimizer} pro optimalizaci bajtkódu a pro každý \texttt{class} soubor vrácený iterátorem \texttt{BytecodeFilesIterator} z~balíčku \texttt{jbyco.io} zavolá jeho metodu \texttt{optimizeClassFile}. Ke sběru informací o~provedených optimalizacích slouží třída \texttt{Statistics}. Třídy implementující optimalizační metody pro expanzi kódu jsou umístěné v~balíčku \texttt{jbyco.optimization.expansion}, třídy pro zjednodušení kódu jsou v~balíčku \texttt{jbyco.optimization.simplification} a třídy pro redukci kódu jsou obsažené v~balíčku \texttt{jbyco.optimization.reduction}.

\subsubsection{Reprezentace vzorových sekvencí a akcí}

Balíček \texttt{jbyco.optimization.peephole} obsahuje třídy pro implementaci a aplikaci peephole optimalizací. Rozhraní \texttt{Symbol} pro symboly reprezentuje množinu operačních kódů. Má jedinou metodu \texttt{match} s~parametrem \texttt{AbstractInsnNode} z~knihovny ASM, která vrací \texttt{true}, pokud operační kód dané instrukce patří do množiny reprezentované symbolem, jinak \texttt{false}. Toto rozhraní je implementováno výčtem \texttt{Symbols}, kde každý operační kód je reprezentován jedním symbolem a další symboly reprezentují skupiny operačních kódů se stejnými vlastnostmi. Vzorovou sekvenci lze definovat pomocí anotace \texttt{Pattern}, která obsahuje pole symbolů typu \texttt{Symbol}. Metoda anotovaná anotací \texttt{Pattern} je pak považovaná za akci, která se vykoná při nalezení sekvence instrukcí odpovídající vzoru. Parametry metody jsou seznam instrukcí typu \texttt{InsnList} z~knihovny ASM a pole instrukcí typu \texttt{AbstractInsnNode}. Seznam instrukcí je aktuální reprezentací bajtkódu metody. Pole instrukcí pak obsahuje instrukce ze seznamu instrukcí a tvoří nalezenou sekvenci instrukcí. Pomocí prvků tohoto pole lze snadno provádět dodatečné kontroly a modifikovat seznam instrukcí. Návratová hodnota je typu \texttt{boolean} a značí, zda došlo k~modifikaci seznamu instrukcí. Třída \texttt{InsnUtils} slouží akcím jako knihovna užitečných funkcí.

\subsubsection{Hledání vzorových sekvencí a aplikace akcí}

Třída \texttt{Runner} z~balíčku \texttt{jbyco.optimization.peephole} zapouzdřuje hledání vzorů a spouštění odpovídajících akcí. Její metoda \texttt{loadPatterns} načte z~dané třídy akce a vzory a vytvoří se pro ně konečné automaty reprezentované instancemi třídy \texttt{StateMachine}. Akce je po tomto kroku reprezentovaná instancí funkčního rozhraní \texttt{Action} s~metodou \texttt{replace}. Třída \texttt{StateMachine} obsahuje metody pro test, zda lze přečíst vstupní instrukci, pro čtení vstupní instrukce, pro určení, zda je automat v~konečném stavu, a vykonání příslušné akce. 

Metoda \texttt{findAndReplace} třídy \texttt{Runner} slouží k~hledání vzorů a spouštění akcí. Dokud v~daném seznamu instrukcí dochází ke změnám, tak se v~něm opakovaně vyhledává. Pro aktuální instrukci se nejprve ověří, zda nemůže být přečtena některým z~načtených konečných automatů. Pokud ano, je vytvořena kopie tohoto automatu a vložena do fronty běžících automatů. Tato fronta je následně dále zpracovávána. Pokud automat z~fronty běžících automatů přečte aktuální instrukci, pak zůstává, a pokud ji nepřečte, je z~fronty odebrán. Přejde-li automat do koncového stavu, spustí se akce, a modifikuje-li akce seznam instrukcí, fronta běžících automatů se vyprázdní a vyhledávání vzorů se restartuje.

\section{Překlad a spuštění}

TODO

\section{Zhodnocení výstupů programu}\label{Jbyco:Results}

TODO\\
          

